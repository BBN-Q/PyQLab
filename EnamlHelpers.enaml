"""
Reusable widgets for handling lists and dictionaries
"""

from atom.api import (Bool, List, Dict, observe, set_default, Unicode, Enum, Int, ForwardTyped)

from .widgets import QtListStrWidget
from enaml.widgets.api import Window, Container, PushButton, Form, Label, Field, ComboBox
from enaml.stdlib.mapped_view import MappedView
from enaml.core.declarative import d_

from enaml.layout.api import hbox, vbox, spacer

class DictManager(QtListStrWidget):
	"""
	Helper to manage a list next to a set of stack items
	"""
	itemDict = d_(Dict())
	displayFilter = d_(ForwardTyped(lambda x : True))

	def __init__(self, **kwargs):
		if 'displayFilter' in kwargs.keys():
			self.displayFilter = kwargs['displayFilter']
			kwargs.pop('displayFilter')
		self.itemDict = kwargs['itemDict']
		items = filter(displayFilter, self.itemDict.keys())
		super(DictManager, self).__init__(items=items, **kwargs)

	#--------------------------------------------------------------------------
	# Signal handlers
	#--------------------------------------------------------------------------
	def on_edit(self, item):
		""" The signal handler for the item changed signal.
		Need to update the itemDict key whenever a list item changes
		"""
		widget = self.get_widget()
		oldkey = self.items[widget.currentRow()]
		# let the superclass method update the items list
		super(DictManager, self).on_edit(item)
		# now we can grab the new key from the same place
		newkey = self.items[widget.currentRow()]
		# move the actual object in itemDict
		self.itemDict[newkey] = self.itemDict.pop(oldkey)

	#--------------------------------------------------------------------------
	# Observers
	#--------------------------------------------------------------------------
	@observe('items', 'itemDict')
	def _update_proxy(self, change):
		""" An observer which sends state change to the proxy.

		"""
		if self.get_widget():
			if change['name'] == 'items':
				self.set_items(self.items)
		    if change['name'] == 'itemDict':
				self.items = filter(displayFilter, self.itemDict.keys())
	
enamldef DictManagerView(Container): dictview:
	attr dictManager = DictManager(itemDict=myDict, displayFilter=displayFilter)
	attr displayFilter = lambda x : True
	attr myDict
	attr addDialog
	attr modelName
	attr viewMap
	attr viewkwargs = {}
	constraints = [
		hbox(vbox(myList, hbox(addButton, deleteButton, debugButton, spacer)), mapViewCont),
		myList.width <= 300]
	QtListStrWidget: myList:
		hug_width = 'medium'
		items << sorted(dictManager.items, key=lambda x : x.lower())
	Container: mapViewCont:
		hug_width = 'medium'
		MappedView:
			#Hacky thing to catch deletions 
			model << dictManager.itemDict[myList.selected_item] if myList.selected_item else None
			modelkey = modelName
			typemap = viewMap
			kwargs = viewkwargs
	PushButton: addButton:
		text = 'Add'
		clicked ::
			addDialog(dictview, dictManager.itemDict)
	PushButton: deleteButton:
		text = 'Delete'
		clicked ::
			myDict.pop(myList.selected_item)
	PushButton: debugButton:
		text = 'Debug'
		clicked ::
			import pdb; pdb.set_trace()

enamldef AddDialog(Window):
	attr itemDict
	attr newClassList
	attr objText
	attr kwargs : dict = {}
	title = 'Add a new {}...'.format(objText)
	modality = 'window_modal'
	Container:
		constraints = [vbox(myForm, hbox(spacer, okButton, cancelButton))]
		Form: myForm:
			Label:
				text = 'New Name'
			Field: newName:
				text = 'New'+objText
			Label:
				text = 'New {} Model'.format(objText)
			ComboBox: modelChoice:
				index = 0
				items = [f.__name__ for f in newClassList]
		PushButton: okButton:
			text = 'OK'
			clicked ::
				# itemDict.update({newName.text:newClassList[modelChoice.index](name=newName.text, **kwargs)})
				itemDict[newName.text] = newClassList[modelChoice.index](name=newName.text, **kwargs)
				close()
		PushButton: cancelButton:
			text = 'Cancel'
			clicked ::
				close()

#A combo box connected to a Enum trait
enamldef EnumComboBox(ComboBox):
	attr obj
	attr enumName
	attr itemList = list(obj.get_member(enumName).items)
	items = itemList
	index << itemList.index(getattr(obj, enumName))
	index :: setattr(obj, enumName, itemList[index])
	tool_tip = obj.get_member(enumName).metadata["desc"]

enamldef EnumFloatComboBox(ComboBox):
	attr obj
	attr floatName
	attr itemList = [str(item) for item in list(obj.get_member(floatName).items)]
	items = itemList
	index << itemList.index(str(getattr(obj, floatName)))
	index :: setattr(obj, floatName, float(itemList[index]))
	tool_tip = obj.get_member(floatName).metadata["desc"]

