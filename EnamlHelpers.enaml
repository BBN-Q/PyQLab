"""
Reusable widgets for handling lists and dictionaries
"""

from atom.api import (Bool, List, Dict, observe, set_default, Unicode, Enum, Int, Callable, Typed)

from widgets.qt_list_str_widget import QtListStrWidget
from enaml.widgets.api import Window, Container, PushButton, Form, Label, Field, ComboBox
from enaml.stdlib.mapped_view import MappedView
from enaml.core.declarative import d_

from enaml.layout.api import hbox, vbox, spacer

import instruments.MicrowaveSources
import instruments.MicrowaveSourcesViews

class DictManager(QtListStrWidget):
	"""
	Helper to manage a list next to a set of stack items
	"""
	itemDict = d_(Dict())
	displayFilter = d_(Callable())

	# def __init__(self, **kwargs):
	# 	if 'displayFilter' in kwargs:
	# 		self.displayFilter = kwargs.pop('displayFilter')
	# 	for k,v in kwargs['itemDict'].items():
	# 		self.itemDict[k] = v
	# 	kwargs.pop('itemDict')
	# 	items = filter(self.displayFilter, self.itemDict.keys())
	# 	super(DictManager, self).__init__(items=items, **kwargs)

	def create_widget(self, parent):
		self.items = filter(self.displayFilter, self.itemDict.keys())
		return super(DictManager, self).create_widget(parent)

	#--------------------------------------------------------------------------
	# Signal handlers
	#--------------------------------------------------------------------------
	def on_edit(self, item):
		""" The signal handler for the item changed signal.
		Need to update the itemDict key whenever a list item changes
		"""
		widget = self.get_widget()
		oldkey = self.items[widget.currentRow()]
		newkey = self.items[widget.currentRow()].text()
		self.itemDict[newkey] = self.itemDict.pop(oldkey)
		# let the superclass method update the items list
		super(DictManager, self).on_edit(item)

	#--------------------------------------------------------------------------
	# Observers
	#--------------------------------------------------------------------------
	@observe('items', 'itemDict')
	def _update_proxy(self, change):
		""" An observer which sends state change to the proxy.

		"""
		if self.get_widget():
			if change['name'] == 'items':
				self.set_items(self.items)
			if change['name'] == 'itemDict':
				self.items = filter(displayFilter, self.itemDict.keys())
	
enamldef DictManagerView(Container): dictview:
	# attr dictManager = DictManager(itemDict=myDict, displayFilter=displayFilter)
	attr myDict
	attr displayFilter = lambda x : True
	attr modelName
	attr viewMap
	attr viewkwargs = {}
	constraints = [
		hbox(vbox(dictManager, hbox(addButton, deleteButton, debugButton, spacer)), mapViewCont),
		dictManager.width <= 300]
	DictManager: dictManager:
		hug_width = 'medium'
		# items << sorted(dictManager.itemDict.keys(), key=lambda x : x.lower())
		itemDict := dict(myDict)
		displayFilter = dictview.displayFilter
	Container: mapViewCont:
		hug_width = 'medium'
		MappedView:
			#Hacky thing to catch deletions 
			model << dictManager.itemDict[dictManager.selected_item] if dictManager.selected_item else None
			modelkey = modelName
			typemap = viewMap
			kwargs = viewkwargs
	PushButton: addButton:
		text = 'Add'
		clicked ::
			newClassList = [n for n in viewMap.keys() if n]
			AddDialog(dictview, dictManager=dictManager, newClassList=newClassList, objText=modelName)
	PushButton: deleteButton:
		text = 'Delete'
		clicked ::
			dictManager.itemDict.pop(dictManager.selected_item)
			dictManager._update_proxy({'name': 'itemDict'})
	PushButton: debugButton:
		text = 'Debug'
		clicked ::
			import pdb; pdb.set_trace()

enamldef AddDialog(Window):
	attr dictManager
	attr newClassList
	attr objText
	title = 'Add a new {}...'.format(objText)
	modality = 'window_modal'
	Container:
		constraints = [vbox(myForm, hbox(spacer, okButton, cancelButton))]
		Form: myForm:
			Label:
				text = 'New Name'
			Field: newName:
				text = 'New'+objText
			Label:
				text = 'New {} Model'.format(objText)
			ComboBox: modelChoice:
				index = 0
				items = [f.__name__ for f in newClassList]
		PushButton: okButton:
			text = 'OK'
			clicked ::
				dictManager.itemDict[newName.text] = newClassList[modelChoice.index](label=newName.text)
				dictManager._update_proxy({'name': 'itemDict'})
				close()
		PushButton: cancelButton:
			text = 'Cancel'
			clicked ::
				close()

