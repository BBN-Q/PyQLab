"""
Reusable widgets for handling lists and dictionaries
"""

from atom.api import (Bool, List, Dict, observe, set_default, Unicode, Enum, Int, Callable, Typed, Atom)

from widgets import QtListStrWidget, AddDialog
from enaml.widgets.api import Window, Container, PushButton, Form, Label, Field, ComboBox
from enaml.stdlib.mapped_view import MappedView
from enaml.core.declarative import d_

from enaml.layout.api import hbox, vbox, spacer

class DictManager(QtListStrWidget):
	"""
	Helper to manage a list next to a set of stack items
	"""
	itemDict = d_(Dict())
	displayFilter = d_(Callable())

	# def __init__(self, **kwargs):
	# 	if 'displayFilter' in kwargs:
	# 		self.displayFilter = kwargs.pop('displayFilter')
	# 	for k,v in kwargs['itemDict'].items():
	# 		self.itemDict[k] = v
	# 	kwargs.pop('itemDict')
	# 	items = filter(self.displayFilter, self.itemDict.keys())
	# 	super(DictManager, self).__init__(items=items, **kwargs)

	def create_widget(self, parent):
		self.items = sorted([k for k,v in self.itemDict.items() if self.displayFilter(v)])
		return super(DictManager, self).create_widget(parent)

	#--------------------------------------------------------------------------
	# Signal handlers
	#--------------------------------------------------------------------------
	def on_edit(self, item):
		""" The signal handler for the item changed signal.
		Need to update the itemDict key whenever a list item changes
		"""
		widget = self.get_widget()
		oldkey = self.items[widget.currentRow()]
		newkey = item.text()
		self.itemDict[newkey] = self.itemDict.pop(oldkey)
		self.itemDict[newkey].label = newkey
		# let the superclass method update the items list
		super(DictManager, self).on_edit(item)

	#--------------------------------------------------------------------------
	# Observers
	#--------------------------------------------------------------------------
	@observe('itemDict')
	def update_itemDict(self, change={'operation': 'set'}):
		if self.get_widget():
			if change['operation'] == 'set':
				self.items = sorted([k for k,v in self.itemDict.items() if self.displayFilter(v)])
			elif change['operation'] == 'add':
				self.items = self.items + [change['item']]
	
enamldef DictManagerView(Container): dictview:
	attr myDict
	attr displayFilter = lambda x : True
	attr modelName
	attr viewMap
	attr viewkwargs = {}
	attr newClassList
	constraints = [
		hbox(vbox(dictManager, hbox(addButton, deleteButton, debugButton, spacer)), mapViewCont),
		dictManager.width <= 300]
	DictManager: dictManager:
		hug_width = 'medium'
		itemDict := myDict
		displayFilter = dictview.displayFilter
	Container: mapViewCont:
		hug_width = 'medium'
		MappedView:
			#Hacky thing to catch deletions 
			model << dictManager.itemDict[dictManager.selected_item] if dictManager.selected_item else None
			modelkey = modelName
			typemap = viewMap
			kwargs = viewkwargs
	PushButton: addButton:
		text = 'Add'
		clicked ::
			dlg = AddDialog(root_object(), dictManager=dictManager, newClassList=newClassList, objText=modelName)
			dlg.show()
	PushButton: deleteButton:
		text = 'Delete'
		clicked ::
			dictManager.itemDict.pop(dictManager.selected_item)
			dictManager.update_itemDict()
	PushButton: debugButton:
		text = 'Debug'
		clicked ::
			import pdb; pdb.set_trace()

