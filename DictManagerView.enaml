"""
Reusable widgets for handling lists and dictionaries
"""

from widgets import QtListStrWidget
from enaml.widgets.api import Window, Container, PushButton, Form, Label, Field, ComboBox
from enaml.stdlib.mapped_view import MappedView
from enaml.core.declarative import d_

from enaml.layout.api import hbox, vbox, spacer


enamldef DictManagerView(Container): dictView:
	"""
	Display a list of items on the left; a view of the selected item on the right and some add/delete buttons.
	"""
	attr dictManager
	attr viewMap # dictionary mapping classes to views
	attr modelName # attr name for the model in the view

	constraints = [
		hbox(
			vbox(
				itemList,
				hbox(addButton, removeButton, spacer),
				spacer
				),
			selectedItemView,
			spacer
			)
		]

	QtListStrWidget: itemList:
		items := dictManager.displayList
		checked_states = [i.enabled for i in dictManager.itemDict.values()]
		initialized :: 
			itemList.item_changed.connect(dictManager.name_changed)
			itemList.enable_changed.connect(dictManager.update_enable)

	PushButton: addButton:
		text = "Add"
		clicked :: dictManager.add_item(self)
	PushButton: removeButton:
		text = "Remove"
		clicked :: dictManager.remove_item(itemList.selected_item)
	Container: selectedItemView:
		MappedView: 
			model << dictManager.itemDict[itemList.selected_item] if itemList.selected_item else None
			typemap = dictView.viewMap
			modelkey = dictView.modelName



# class DictManager(QtListStrWidget):
# 	"""
# 	Helper to manage a list next to a set of stack items
# 	"""
# 	itemDict = d_(Dict())
# 	displayFilter = d_(Callable())
# 	selected_model = Typed(Atom)

# 	def create_widget(self, parent):
# 		self.items = sorted([k for k,v in self.itemDict.items() if self.displayFilter(v)])
# 		self.selected_model = None
# 		return super(DictManager, self).create_widget(parent)

# 	def add(self, label, value):
# 		self.itemDict[label] = value
# 		self.itemDict_observer({'type': 'append', 'value': label})

# 	def remove_selection(self):
# 		self.itemDict.pop(self.selected_item)
# 		self.itemDict_observer({'type': 'remove', 'value': self.selected_index})

# 	#--------------------------------------------------------------------------
# 	# Signal handlers
# 	#--------------------------------------------------------------------------
# 	def on_edit(self, item):
# 		""" The signal handler for the item changed signal.
# 		Need to update the itemDict key whenever a list item changes
# 		"""
# 		widget = self.get_widget()
# 		oldkey = self.items[widget.currentRow()]
# 		newkey = item.text()
# 		self.itemDict[newkey] = self.itemDict.pop(oldkey)
# 		self.itemDict[newkey].label = newkey
# 		# let the superclass method update the items list
# 		super(DictManager, self).on_edit(item)

# 	def on_selection(self):
# 		super(DictManager, self).on_selection()
# 		self.selected_model = self.itemDict[self.selected_item]

# 	#--------------------------------------------------------------------------
# 	# Observers
# 	#--------------------------------------------------------------------------
# 	@observe('itemDict')
# 	def itemDict_observer(self, change={'type': 'set'}):
# 		if self.get_widget():
# 			if change['type'] == 'set':
# 				self.items = sorted([k for k,v in self.itemDict.items() if self.displayFilter(v)])
# 			elif change['type'] == 'append':
# 				self.items = self.items + [change['value']]
# 			elif change['type'] == 'remove':
# 				self.items = self.items[:change['value']] + self.items[change['value']+1:]
	
# enamldef DictManagerView(Container): dictview:
# 	attr myDict
# 	attr displayFilter = lambda x : True
# 	attr modelName
# 	attr viewMap
# 	attr viewkwargs = {}
# 	attr newClassList
# 	constraints = [
# 		hbox(vbox(dictManager, hbox(addButton, deleteButton, debugButton, spacer)), mapViewCont),
# 		dictManager.width <= 300]
# 	DictManager: dictManager:
# 		hug_width = 'medium'
# 		itemDict := myDict
# 		displayFilter = dictview.displayFilter
# 	Container: mapViewCont:
# 		hug_width = 'medium'
# 		MappedView:
# 			model << dictManager.selected_model
# 			modelkey = modelName
# 			typemap = viewMap
# 			kwargs = viewkwargs
# 	PushButton: addButton:
# 		text = 'Add'
# 		clicked ::
# 			dlg = AddDialog(root_object(), dictManager=dictManager, newClassList=newClassList, objText=modelName)
# 			dlg.show()
# 	PushButton: deleteButton:
# 		text = 'Delete'
# 		clicked ::
# 			dictManager.remove_selection()
# 	PushButton: debugButton:
# 		text = 'Debug'
# 		clicked ::
# 			import pdb; pdb.set_trace()

