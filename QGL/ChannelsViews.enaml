from enaml.widgets.api import Window, Container, Notebook, Page, PushButton, GroupBox, Form, Label, Field, \
                             ComboBox
from enaml.stdlib.fields import FloatField
from enaml.layout.api import hbox, vbox, spacer
from enaml.core.api import Looper, Conditional

from DictManagerView import DictManagerView
from widgets import EnumComboBox

import QGL.Channels
from instruments.AWGs import AWG
from instruments.MicrowaveSources import MicrowaveSource

import QGL.PulseShapes
from types import FunctionType
psList = [f for f in QGL.PulseShapes.__dict__.values() if isinstance(f, FunctionType)]

from ExpSettingsVal import is_valid_awg_channel_name

def setIfNotEmpty(lvalue, library, item):
    if item != '':
        lvalue = library[item]
    else:
        lvalue.label = ''
    return lvalue

enamldef LogicalMarkerChannelView(GroupBox): curView:
    attr chan
    attr channelLib
    attr instrumentLib
    title := '{} (LogicalMarker)'.format(chan.label)
    Form:
        Label:
            text = 'Physical Chan.'
        ComboBox:
            items << [item.label for item in curView.channelLib.values() if isinstance(item, QGL.Channels.PhysicalMarkerChannel)]
            index << filter(lambda item : isinstance(item, QGL.Channels.PhysicalMarkerChannel), curView.channelLib.values()).index(chan.physChan) if chan.physChan in curView.channelLib.values() else -1
            index ::
                chan.physChan = filter(lambda item : isinstance(item, QGL.Channels.PhysicalMarkerChannel), curView.channelLib.values())[index]
        Looper:
            iterable << sorted(chan.pulseParams.keys())
            Label:
                text = loop_item
            Conditional:
                condition = isinstance(chan.pulseParams[loop_item], float) or isinstance(chan.pulseParams[loop_item], int)
                FloatField:
                    value << float(chan.pulseParams[loop_item])
                    value >> chan.pulseParams[loop_item]
            Conditional:
                condition = isinstance(chan.pulseParams[loop_item], FunctionType)
                ComboBox:
                    items << [f.__name__ for f in psList]
                    index << psList.index(chan.pulseParams[loop_item])
                    index ::
                        chan.pulseParams[loop_item] = psList[index]

enamldef PhysicalMarkerChannelView(GroupBox): curView:
    attr chan
    attr channelLib
    attr instrumentLib
    title := '{} (PhysicalMarker)'.format(chan.label)
    Form:
        Label:
            text = 'Delay (s)'
        FloatField:
            value := chan.delay
        Label:
            text = 'Gate Buffer (s)'
        FloatField:
            value := chan.gateBuffer
        Label:
            text = 'Min Pulse Width (s)'
        FloatField:
            value := chan.gateMinWidth
        Label:
            text = 'AWG'
        ComboBox:
            items << instrumentLib.AWGs.displayList
            index << instrumentLib.AWGs.displayList.index(chan.AWG.label) if (chan.AWG.label in instrumentLib.AWGs.displayList) else -1
            index ::
                chan.AWG = setIfNotEmpty(chan.AWG, instrumentLib, selected_item)

enamldef PhysicalQuadratureChannelView(GroupBox): curView:
    attr chan
    attr channelLib
    attr instrumentLib
    title := '{} (PhysicalQuadrature)'.format(chan.label)
    Form:
        Label:
            text = 'AWG'
        ComboBox:
            items << instrumentLib.AWGs.displayList
            index << instrumentLib.AWGs.displayList.index(chan.AWG.label) if (chan.AWG.label in instrumentLib.AWGs.displayList) else -1
            index ::
                chan.AWG = setIfNotEmpty(chan.AWG, instrumentLib, selected_item)
        Label:
            text = 'Source'
        ComboBox:
            items << instrumentLib.sources.displayList
            index << instrumentLib.sources.displayList.index(chan.generator.label) if (chan.generator and chan.generator.label in instrumentLib.sources.displayList) else -1
            index ::
                chan.generator = setIfNotEmpty(chan.generator, instrumentLib, selected_item)
        Label:
            text = 'Delay (s)'
        FloatField:
            value := chan.delay
        Label:
            text = 'Amp. Factor'
        FloatField:
            value := chan.ampFactor
        Label:
            text = 'Phase Skew (deg.)'
        FloatField:
            value := chan.phaseSkew
        

enamldef LogicalQuadratureView(GroupBox): curView:
    attr chan
    attr channelLib
    title := '{} ({})'.format(chan.label, chan.__class__.__name__)
    Form:
        Conditional:
            condition = isinstance(chan, QGL.Channels.Measurement)
            Label:
                text = 'Type'
            EnumComboBox:
                obj := chan
                enumName = 'measType'
            Conditional:
                condition << chan.measType == 'autodyne'
                Label:
                    text = 'Autodyne Freq. (MHz)'
                FloatField:
                    value << chan.autodyneFreq/1e6
                    value :: chan.autodyneFreq = value*1e6
                    tool_tip = chan.get_member('autodyneFreq').metadata["desc"]
            Label:
                text = 'Trigger Chan.'
            ComboBox:
                items << channelLib.logicalChannelManager.displayList
                index << channelLib.logicalChannelManager.displayList.index(chan.trigChan.label) if (chan.trigChan and chan.trigChan.label in channelLib.logicalChannelManager.displayList) else -1
                index ::
                    chan.trigChan = setIfNotEmpty(chan.trigChan, channelLib, selected_item)
        Conditional:
            condition = isinstance(chan, QGL.Channels.Edge)
            Label:
                text = 'Source Qubit'
            ComboBox:
                items << channelLib.logicalChannelManager.displayList
                index << channelLib.logicalChannelManager.displayList.index(chan.source.label) if (chan.source and chan.source.label in channelLib.logicalChannelManager.displayList) else -1
                index ::
                    chan.source = setIfNotEmpty(chan.source, channelLib, selected_item)
            Label:
                text = 'Target Qubit'
            ComboBox:
                items << channelLib.logicalChannelManager.displayList
                index << channelLib.logicalChannelManager.displayList.index(chan.target.label) if (chan.target and chan.target.label in channelLib.logicalChannelManager.displayList) else -1
                index ::
                    chan.target = setIfNotEmpty(chan.target, channelLib, selected_item)
        Label:
            text = 'Frequency (MHz)'
        FloatField:
            value << chan.frequency/1e6
            value :: chan.frequency = value*1e6
            tool_tip = chan.get_member('frequency').metadata["desc"]
        Label:
            text = 'Physical Chan.'
        ComboBox:
            items << channelLib.physicalChannelManager.displayList
            index << channelLib.physicalChannelManager.displayList.index(chan.physChan.label) if (chan.physChan and chan.physChan.label in channelLib.physicalChannelManager.displayList) else -1
            index ::
                chan.physChan = setIfNotEmpty(chan.physChan, channelLib, selected_item)
        Label:
            text = 'Gate Chan.'
        ComboBox:
            items << channelLib.logicalChannelManager.displayList
            index << channelLib.logicalChannelManager.displayList.index(chan.gateChan.label) if (chan.gateChan and chan.gateChan.label in channelLib.logicalChannelManager.displayList) else -1
            index ::
                chan.gateChan = setIfNotEmpty(chan.gateChan, channelLib, selected_item)
        Looper:
            iterable << sorted(chan.pulseParams.keys())
            Label:
                text = loop_item
            Conditional:
                condition = isinstance(chan.pulseParams[loop_item], float) or isinstance(chan.pulseParams[loop_item], int)
                FloatField:
                    value << float(chan.pulseParams[loop_item])
                    value >> chan.pulseParams[loop_item]
            Conditional:
                condition = isinstance(chan.pulseParams[loop_item], FunctionType)
                ComboBox:
                    items << [f.__name__ for f in psList]
                    index << psList.index(chan.pulseParams[loop_item])
                    index ::
                        chan.pulseParams[loop_item] = psList[index]
        

enamldef EmptyChannelView(Container):
    attr chan
    attr channelLib
    attr instrumentLib

ChannelViewMap = {
    type(None): EmptyChannelView,
    QGL.Channels.Qubit: LogicalQuadratureView,
    QGL.Channels.Measurement: LogicalQuadratureView,
    QGL.Channels.Edge: LogicalQuadratureView,
    QGL.Channels.LogicalMarkerChannel: LogicalMarkerChannelView,
    QGL.Channels.PhysicalQuadratureChannel: PhysicalQuadratureChannelView,
    QGL.Channels.PhysicalMarkerChannel: PhysicalMarkerChannelView
}

enamldef ChannelLibraryView(Container): channelLibCont:
    attr channelLib
    attr instrumentLib
    Notebook:
        tab_style = 'preferences'
        Page:
            title = 'Logical'
            closable = False
            DictManagerView:
                dictManager = channelLib.logicalChannelManager
                # displayFilter = lambda x : isinstance(x, QGL.Channels.LogicalChannel)
                modelName = 'chan'
                viewMap = ChannelViewMap
                viewkwargs = {'channelLib': channelLib}
                # newClassList = QGL.Channels.NewLogicalChannelList
        Page:
            title = "Physical"
            closable = False
            DictManagerView:
                dictManager = channelLib.physicalChannelManager
                # displayFilter = lambda x : isinstance(x, QGL.Channels.PhysicalChannel)
                modelName = 'chan'
                viewMap = ChannelViewMap
                viewkwargs = {'instrumentLib': instrumentLib,
                                'channelLib': channelLib}
                labelValidator = is_valid_awg_channel_name
                # newClassList = QGL.Channels.NewPhysicalChannelList

enamldef ChannelLibraryWindow(Window): channelLibWin:
    attr channelLib
    attr instrumentLib
    title = 'Channel Library'
    Container:
        ChannelLibraryView:
            channelLib = channelLibWin.channelLib
            instrumentLib = channelLibWin.instrumentLib
